name: CI

on:
  push:
  pull_request:
    types:
      - opened
      - synchronize
  release:
    types:
      - published

env:
  NODE_VERSION: 18
  CONST_RANDOM_SEED: ${{ secrets.CONST_RANDOM_SEED }}
  DEBIAN_FRONTEND: noninteractive

jobs:
  static-analysis:
    name: Static analysis

    runs-on: ubuntu-latest
    timeout-minutes: 15

    # Exclude in-repo PRs from running this job
    if: github.event_name != 'pull_request' || github.event.pull_request.head.repo.fork

    steps:
      - name: ğŸ“¥ Checkout source
        uses: actions/checkout@v3

      # Necessary due to Tauri macro expectations. See: https://github.com/tauri-apps/tauri/issues/3142
      - name: ğŸ“ Create GUI package frontend dist directory
        run: mkdir packages/packsquash_gui/dist

      - name: ğŸ§° Install development packages
        run: |
          sudo apt-get update
          sudo apt-get install desktop-file-utils libwebkit2gtk-4.0-dev

      - name: ğŸ§° Install Rust toolchain
        uses: dtolnay/rust-toolchain@nightly
        with:
          components: rustfmt, clippy

      - name: ğŸ§° Install Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm
          cache-dependency-path: '**/package-lock.json'

      - name: ğŸ” Clippy check
        uses: giraffate/clippy-action@v1
        with:
          clippy_flags: --all-targets -D warnings
          reporter: github-check
          fail_on_error: true

      - name: ğŸ” ESLint check
        working-directory: packages/packsquash_gui
        run: |
          npm ci
          npm run lint

      - name: ğŸ” Cargo deny check
        uses: EmbarkStudios/cargo-deny-action@v1

      - name: ğŸ” Check PackSquash Linux desktop entries correctness
        run: bash -ce 'shopt -s globstar; desktop-file-validate **/*.desktop'

      - name: ğŸ” Check Rust source code format
        run: cargo fmt --all --check

      - name: ğŸ” Check TypeScript source code format
        working-directory: packages/packsquash_gui
        run: npm run format

  build:
    name: Build

    strategy:
      fail-fast: false
      matrix:
        target:
          - x86_64-unknown-linux-gnu
          - x86_64-unknown-linux-musl
          - x86_64-pc-windows-gnu
          - aarch64-unknown-linux-gnu
          - aarch64-unknown-linux-musl
          - x86_64-apple-darwin
          - aarch64-apple-darwin

        include:
          - target: x86_64-unknown-linux-gnu
            host-target: x86_64-unknown-linux-gnu
            runner: ubuntu-latest
            container: debian:bullseye-slim
            apt-arch: amd64
            appimage-arch: x86_64

          - target: x86_64-unknown-linux-musl
            host-target: x86_64-unknown-linux-gnu
            runner: ubuntu-latest
            container: debian:testing-slim
            apt-arch: amd64
            # Exclude the GUI because showing a webview depends by design
            # on dynamically-linked libraries, and statically linking to
            # musl just doesn't fit that
            excluded-packages: --exclude packsquash_gui

          - target: x86_64-pc-windows-gnu
            host-target: x86_64-pc-windows-gnu
            runner: windows-latest

          - target: aarch64-unknown-linux-gnu
            host-target: x86_64-unknown-linux-gnu
            runner: ubuntu-latest
            container: debian:bullseye-slim
            pkg-config-path: /usr/lib/aarch64-linux-gnu/pkgconfig
            apt-arch: arm64
            appimage-arch: aarch64

          - target: aarch64-unknown-linux-musl
            host-target: x86_64-unknown-linux-gnu
            runner: ubuntu-latest
            container: debian:testing-slim
            apt-arch: arm64
            excluded-packages: --exclude packsquash_gui

          - target: x86_64-apple-darwin
            host-target: x86_64-apple-darwin
            extra-targets: aarch64-apple-darwin
            tauri-target: universal-apple-darwin
            runner: macos-latest

          - target: aarch64-apple-darwin
            host-target: x86_64-apple-darwin
            runner: macos-latest

    runs-on: ${{ matrix.runner }}
    timeout-minutes: 60

    container: ${{ matrix.container }}

    env:
      CARGO_BUILD_TARGET: ${{ matrix.target }}
      # nextext requires this on Windows to pick the intended GNU toolchain
      RUSTUP_TOOLCHAIN: nightly-${{ matrix.host-target }}

      # Rust stdlib default backtrace feature doesn't actually work because our
      # release executables are stripped, so skipping it shaves off quite some KiB.
      # References:
      # https://doc.rust-lang.org/cargo/reference/unstable.html#build-std-features
      # https://github.com/rust-lang/rust/blob/4c8bb79d9f565115637cc6da739f8389e79f3a29/library/std/Cargo.toml#L54-L79
      OPTIMIZED_RELEASE_BUILD_FLAGS: -Z build-std -Z build-std-features=panic-unwind

      TARGET_APPIMAGE_ARCH: ${{ matrix.appimage-arch }}
      TARGET_APPIMAGE_APT_ARCH: ${{ matrix.apt-arch }}

      PKG_CONFIG_ALLOW_CROSS: 1
      PKG_CONFIG_PATH: ${{ matrix.pkg-config-path }}

    # Exclude in-repo PRs from running this job
    if: github.event_name != 'pull_request' || github.event.pull_request.head.repo.fork

    steps:
      - name: ğŸ§° Install Linux toolchain packages
        if: contains(matrix.target, '-linux-')
        run: |
          if [ "$(dpkg --print-architecture)" != '${{ matrix.apt-arch }}' ]; then
            dpkg --add-architecture '${{ matrix.apt-arch }}'
          fi
          apt-get update
          # curl is required by rustup and Tauri.
          # musl-tools is required to build musl binaries for the host architecture,
          # and the arch-specific musl-dev package is required to build binaries for
          # a target architecture when cross-compiling.
          # The third line contains packages neccessary for Tauri.
          # The fourth line contains packages necessary for build-time JSON
          # Schema generation.
          # The fifth line contains packages necessary for headless GUI testing.
          # The sixth line contains packages necessary for appimage-builder.
          # markdown and html2text are required to generate the Debian package.
          apt-get install -yq build-essential git curl \
                              musl-tools musl-dev:${{ matrix.apt-arch }} \
                              libwebkit2gtk-4.0-dev:${{ matrix.apt-arch }} zlib1g-dev \
                              jq \
                              $(if [ "$CARGO_BUILD_TARGET" = 'x86_64-unknown-linux-gnu' ]; then printf 'xserver-xorg xserver-xorg-video-dummy xinit webkit2gtk-driver'; fi) \
                              python3-venv file zsync desktop-file-utils gtk-update-icon-cache fakeroot squashfs-tools gstreamer1.0-tools \
                              markdown html2text

      - name: ğŸ§° Install Edge WebDriver for the WebView2 runtime
        if: contains(matrix.target, '-windows-')
        run: |
          $tmp_file = New-TemporaryFile | Rename-Item -NewName { $_.Name -replace '.tmp', '.zip' } -PassThru
          Invoke-WebRequest -Uri 'https://msedgedriver.azureedge.net/105.0.1343.27/edgedriver_win64.zip' -OutFile "$tmp_file"
          $tmp_file | Expand-Archive -DestinationPath "$env:RUNNER_TEMP\edgedriver" -Force
          $tmp_file | Remove-Item
          "NATIVE_WEBDRIVER_BINARY=$env:RUNNER_TEMP\edgedriver\msedgedriver.exe" | Out-File -FilePath "$env:GITHUB_ENV" -Encoding utf8 -Append

      # The GitHub Windows and macOS images already have jq, git and the build-essential equivalents installed,
      # so we don't need to install them explicitly. However, that may not be the case in different environments

      - name: ğŸ§° Install Linux ARM64 cross-compilation toolchain
        if: startsWith(matrix.target, 'aarch64-unknown-linux')
        run: apt-get install -yq gcc-aarch64-linux-gnu qemu-user libc6:arm64

      - name: ğŸ§° Install Rust toolchain
        uses: dtolnay/rust-toolchain@nightly
        with:
          toolchain: ${{ env.RUSTUP_TOOLCHAIN }}
          targets: ${{ matrix.target }} ${{ matrix.extra-targets }}
          components: rust-src

      - name: ğŸ’¨ Cache Rust artifacts
        uses: Swatinem/rust-cache@v2

      - name: ğŸ§° Install nextest
        if: startsWith(matrix.target, 'x86_64-') || contains(matrix.target, '-linux-')
        uses: taiki-e/install-action@v2
        with:
          tool: nextest

      - name: ğŸ§° Install cargo-deb
        if: endsWith(matrix.target, '-linux-gnu')
        uses: taiki-e/install-action@v2
        with:
          tool: cargo-deb

      - name: ğŸ§° Install tauri-driver
        if: matrix.target == 'x86_64-unknown-linux-gnu' || contains(matrix.target, '-windows-')
        run: cargo install --locked --git https://github.com/ComunidadAylas/tauri.git tauri-driver

      - name: ğŸ§° Install tauri-cli
        if: contains(matrix.target, '-windows-') || matrix.target == 'x86_64-apple-darwin'
        uses: taiki-e/install-action@v2
        with:
          tool: tauri-cli

      - name: ğŸ“¥ Checkout source
        uses: actions/checkout@v3
        with:
          fetch-depth: 0 # Keep the commit history for proper version information

      - name: ğŸ§° Install Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm
          cache-dependency-path: '**/package-lock.json'

      - name: ğŸ§° Install GUI Node dependencies
        working-directory: packages/packsquash_gui
        run: |
          npm config set color always
          npm ci

      # Necessary for steps that invoke Git commands to work properly on workflows run on containers.
      # See: https://github.com/actions/checkout/issues/766
      - name: ğŸ“¥ Set source ownership to current user
        if: startsWith(matrix.runner, 'ubuntu')
        run: chown -R "$(id -u):$(id -g)" "$GITHUB_WORKSPACE"

      # Necessary due to Tauri macro expectations. See: https://github.com/tauri-apps/tauri/issues/3142
      - name: ğŸ“ Create GUI package frontend dist directory
        run: mkdir packages/packsquash_gui/dist

      # Our build container is minimal, and it doesn't contain any systemd package.
      # systemd is responsible for setting up the machine ID files we use for
      # testing the system ID retrieval code, so copy a dummy one
      - name: ğŸ“ Set up a dummy D-Bus machine ID for tests
        if: startsWith(matrix.runner, 'ubuntu')
        run: cat /proc/sys/kernel/random/uuid | tr -d '-' > /run/machine-id

      # We can only run tests if the target architecture matches the host architecture,
      # or if the target (and therefore host) OS is Linux, as we can leverage QEMU there
      - name: âœ”ï¸ Run tests
        if: startsWith(matrix.target, 'x86_64-') || contains(matrix.target, '-linux-')
        run: |
          cargo nextest run --release --workspace --status-level all ${{ matrix.excluded-packages }}
          cargo test --doc --release --workspace ${{ matrix.excluded-packages }}

      - name: âœ”ï¸ Run GUI E2E tests (Linux)
        if: matrix.target == 'x86_64-unknown-linux-gnu'
        working-directory: packages/packsquash_gui
        env:
          FORCE_COLOR: 1
        run: |
          # E2E GUI tests need to be run in the context of a desktop, which can be headless (i.e., not backed by
          # any graphics device) or powered by a graphics adapter.
          #
          # To achieve a headless desktop on Linux, we employ the stock Xorg server with the dummy video driver.
          # Xvfb, which is a different X server implementation, is more popular for this purpose, but while both
          # of them should work fine for our purposes, the latter doesn't share all the code and thus features
          # with Xorg, so it's less representative of an actual Linux user environment.
          #
          # In the particular case of GitHub-hosted Actions runners, the Azure VM the workflows runs on has a
          # Microsoft Hyper-V Synthetic Video device (PCI ID 1414:5353:0000:0000), which is supported by
          # xserver-xorg-video-fbdev, and could be (ab)used for running a desktop there. However, that's not
          # documented by GitHub, it won't provide OpenGL hardware acceleration, and Xorg insists on opening
          # /dev/tty0 within Docker containers, which it can't and tries to because the Debian Bullseye Xorg
          # package seems to be missing this commit:
          # https://gitlab.freedesktop.org/xorg/xserver/-/commit/b8c12aac651d626c5120e6e8e18b42e7528caf43
          #
          # Xorg is run as root here due to our usage of Docker containers.
          #
          # References:
          # https://wiki.archlinux.org/title/xorg
          # https://fedoraproject.org/wiki/PackageMaintainers/GraphicalTests
          # https://techoverflow.net/2019/02/23/how-to-run-x-server-using-xserver-xorg-video-dummy-driver-on-ubuntu/
          # https://gitlab.freedesktop.org/xorg/driver/xf86-video-dummy/-/blob/master/src/dummy_driver.c
          # https://gitlab.freedesktop.org/xorg/xserver/-/tree/master/hw/vfb
          # https://www.x.org/archive/X11R7.5/doc/man/man5/xorg.conf.5.html

          xinit /bin/sh -c 'npm run test; echo $? > /run/test_exit_code' \
          -- -config /proc/self/fd/0 -logfile /proc/self/fd/2 -quiet <<'XORG_CONF'
          Section "Device"
            Identifier "DummyCard"
            Driver "dummy"
          EndSection

          Section "Screen"
            Identifier "DummyScreen"
            Device "DummyCard"
          EndSection
          XORG_CONF
          exit $(cat /run/test_exit_code)

      - name: âœ”ï¸ Run GUI E2E tests (Windows)
        if: contains(matrix.target, '-windows-')
        working-directory: packages/packsquash_gui
        env:
          FORCE_COLOR: 1
        run: npm run test

      - name: ğŸ”¨ Build GUI frontend
        if: ${{ !contains(matrix.target, '-windows-') && matrix.target != 'x86_64-apple-darwin' && endsWith(matrix.target, '-linux-gnu') }}
        working-directory: packages/packsquash_gui
        run: npm run build

      - name: ğŸ”¨ Build with optimized standard library
        run: cargo build --workspace ${{ matrix.excluded-packages }} --release ${{ env.OPTIMIZED_RELEASE_BUILD_FLAGS }}

      - name: ğŸ”¨ Build GUI, installers and updater artifacts
        if: contains(matrix.target, '-windows-') || matrix.target == 'x86_64-apple-darwin'
        working-directory: packages/packsquash_gui
        env:
          TAURI_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
          TAURI_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}
        run: cargo tauri build -v --target ${{ matrix.tauri-target || matrix.target }}
          -- ${{ env.OPTIMIZED_RELEASE_BUILD_FLAGS }}

      - name: ğŸ”¨ Generate CLI Debian package
        if: endsWith(matrix.target, '-linux-gnu')
        run: packages/packsquash_cli/bundles/deb/build.sh --target ${{ env.CARGO_BUILD_TARGET }}
          -- ${{ env.OPTIMIZED_RELEASE_BUILD_FLAGS }}

      - name: ğŸ”¨ Generate GUI Debian package
        if: endsWith(matrix.target, '-linux-gnu')
        run: packages/packsquash_gui/src-tauri/bundles/deb/build.sh --target ${{ env.CARGO_BUILD_TARGET }}
          -- ${{ env.OPTIMIZED_RELEASE_BUILD_FLAGS }}

      - name: ğŸ”¨ Generate GUI AppImage
        if: endsWith(matrix.target, '-linux-gnu')
        run: packages/packsquash_gui/src-tauri/bundles/appimage/build.sh

      - name: ğŸ”¨ Generate multilingual GUI MSI installer
        if: contains(matrix.target, '-windows-')
        run: packages/packsquash_gui/src-tauri/bundles/wix/build_multilingual_installer.ps1

      - name: ğŸ“¤ Upload GUI E2E test reports
        if: ${{ (!contains(matrix.target, '-linux-') || endsWith(matrix.target, '-linux-musl')) && failure() }}
        uses: actions/upload-artifact@v3
        with:
          name: GUI E2E test reports (${{ matrix.target }})
          if-no-files-found: ignore
          path: packages/packsquash_gui/reports/**/*

      - name: ğŸ“¤ Upload CLI binary
        if: ${{ !contains(matrix.target, '-linux-') || endsWith(matrix.target, '-linux-musl') }}
        uses: actions/upload-artifact@v3
        with:
          name: PackSquash CLI executable (${{ matrix.target }})
          path: |
            target/${{ env.CARGO_BUILD_TARGET }}/release/packsquash
            target/${{ env.CARGO_BUILD_TARGET }}/release/packsquash.exe

      - name: ğŸ“¤ Upload CLI Debian package
        if: endsWith(matrix.target, '-linux-gnu')
        uses: actions/upload-artifact@v3
        with:
          name: PackSquash CLI Debian package (${{ matrix.apt-arch }})
          path: target/${{ env.CARGO_BUILD_TARGET }}/debian/packsquash_*.deb

      - name: ğŸ“¤ Upload GUI Debian package
        if: endsWith(matrix.target, '-linux-gnu')
        uses: actions/upload-artifact@v3
        with:
          name: PackSquash GUI Debian package (${{ matrix.apt-arch }})
          path: target/${{ env.CARGO_BUILD_TARGET }}/debian/packsquash-gui_*.deb

      - name: ğŸ“¤ Upload GUI AppImage
        if: endsWith(matrix.target, '-linux-gnu')
        uses: actions/upload-artifact@v3
        with:
          name: PackSquash GUI AppImage (${{ matrix.appimage-arch }})
          path: target/appimage/PackSquash (GUI)-*-${{ matrix.appimage-arch }}.AppImage

      - name: ğŸ“¤ Upload GUI AppImage update diff
        if: endsWith(matrix.target, '-linux-gnu')
        uses: actions/upload-artifact@v3
        with:
          name: PackSquash GUI AppImage zsync (${{ matrix.appimage-arch }})
          path: target/appimage/PackSquash (GUI)-*-${{ matrix.appimage-arch }}.AppImage.zsync

      - name: ğŸ“¤ Upload GUI MSI installer
        if: contains(matrix.target, '-windows-')
        uses: actions/upload-artifact@v3
        with:
          name: PackSquash GUI MSI installer (${{ matrix.target }})
          path: target/${{ env.CARGO_BUILD_TARGET }}/release/bundle/msi/PackSquash_*_x64.msi

      - name: ğŸ“¤ Upload GUI MSI update bundle
        if: contains(matrix.target, '-windows-')
        uses: actions/upload-artifact@v3
        with:
          name: PackSquash GUI MSI update bundle (${{ matrix.target }})
          path: target/${{ env.CARGO_BUILD_TARGET }}/release/bundle/msi/PackSquash_*_x64_en-US.msi.zip

      - name: ğŸ“¤ Upload GUI MSI update bundle signature
        if: contains(matrix.target, '-windows-')
        uses: actions/upload-artifact@v3
        with:
          name: PackSquash GUI MSI update bundle signature (${{ matrix.target }})
          path: target/${{ env.CARGO_BUILD_TARGET }}/release/bundle/msi/PackSquash_*_x64_en-US.msi.zip.sig

      - name: ğŸ“¤ Upload GUI Apple Disk Image
        if: matrix.target == 'x86_64-apple-darwin'
        uses: actions/upload-artifact@v3
        with:
          name: PackSquash GUI Apple Disk Image (${{ matrix.tauri-target || matrix.target }})
          path: target/${{ matrix.tauri-target || matrix.target }}/release/bundle/dmg/PackSquash_*.dmg

      - name: ğŸ“¤ Upload GUI macOS update bundle
        if: matrix.target == 'x86_64-apple-darwin'
        uses: actions/upload-artifact@v3
        with:
          name: PackSquash GUI macOS update bundle (${{ matrix.tauri-target || matrix.target }})
          path: target/${{ matrix.tauri-target || matrix.target }}/release/bundle/macos/PackSquash.app.tar.gz

      - name: ğŸ“¤ Upload GUI macOS update bundle signature
        if: matrix.target == 'x86_64-apple-darwin'
        uses: actions/upload-artifact@v3
        with:
          name: PackSquash GUI macOS update bundle signature (${{ matrix.tauri-target || matrix.target }})
          path: target/${{ matrix.tauri-target || matrix.target }}/release/bundle/macos/PackSquash.app.tar.gz.sig

  build-universal-macos-binaries:
    name: Build universal macOS binaries

    runs-on: macos-latest

    needs: build

    steps:
      - name: ğŸ“¥ Download PackSquash CLI x64 macOS executable
        uses: actions/download-artifact@v3
        with:
          name: PackSquash CLI executable (x86_64-apple-darwin)
          path: packsquash-x64

      - name: ğŸ“¥ Download PackSquash CLI ARM64 macOS executable
        uses: actions/download-artifact@v3
        with:
          name: PackSquash CLI executable (aarch64-apple-darwin)
          path: packsquash-aarch64

      - name: ğŸ”¨ Generate universal CLI binary
        run: lipo -create -output packsquash packsquash-x64/packsquash packsquash-aarch64/packsquash

      - name: ğŸ“¤ Upload universal CLI binary
        uses: actions/upload-artifact@v3
        with:
          name: PackSquash CLI executable (universal-apple-darwin)
          path: packsquash

  build-docker-images:
    name: Build Docker images

    runs-on: ubuntu-latest

    env:
      # Defaults to docker.io (Docker Hub)
      REGISTRY: ghcr.io
      # github.repository as <account>/<repo>
      IMAGE_NAME: ${{ github.repository }}

    needs: build

    steps:
      - name: ğŸ“¥ Checkout source
        uses: actions/checkout@v3

      - name: ğŸ§° Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: âš™ï¸ Generate Docker image metadata
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          # Tag the image as "edge" for every commit on master.
          # Tag the image by its ref for every commit on non-master branches.
          # Maintain the "latest", full and major and minor semver tags for each semver tag push
          tags: |
            type=edge,branch=master
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=ref,event=branch
          labels: |
            org.opencontainers.image.description=Docker image for PackSquash, the Minecraft resource and data pack optimizer.

      - name: ğŸ“¥ Download PackSquash CLI x64 musl executable
        uses: actions/download-artifact@v3
        with:
          name: PackSquash CLI executable (x86_64-unknown-linux-musl)

      - name: ğŸ“ Rename PackSquash CLI x64 musl executable
        run: mv packsquash packsquash-amd64

      - name: ğŸ“¥ Download PackSquash CLI ARM64 musl executable
        uses: actions/download-artifact@v3
        with:
          name: PackSquash CLI executable (aarch64-unknown-linux-musl)

      - name: ğŸ“ Rename PackSquash CLI ARM64 musl executable
        run: mv packsquash packsquash-arm64

      - name: ğŸ” Check workflow package write permission
        id: check_write_permission
        uses: assaferan/action-has-permission@3d96069159254de543039461dc5a9c20fadbd6e6
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # The GitHub token needs the package:write permission for the push to work.
      # This permission is not given to PRs from forked repositories.
      # See: https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token
      - name: âš™ï¸ Login to ${{ env.REGISTRY }}
        uses: docker/login-action@v2
        if: steps.check_write_permission.outputs.has-permission
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ”¨ Build and push Docker image
        uses: docker/build-push-action@v4
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: ${{ steps.check_write_permission.outputs.has-permission == '1' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
